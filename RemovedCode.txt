class WaterParticle
        {
            private double sedimentCapacity;
            private double sedimentCarried;
            public WaterParticle(double sedimentCapacity, double sedimentCarried)
            {
                this.sedimentCapacity = sedimentCapacity;
                this.sedimentCarried = sedimentCarried;
            }

            public double getCapacity()
            {
                return sedimentCapacity;
            }

            public double getCarried()
            {
                return sedimentCarried;
            }

            public void setCapacity(double capacity)
            {
                sedimentCapacity = capacity;
            }

            public void setCarried(double carried)
            {
                sedimentCarried = carried;
            }

            public double calculateLoad()
            {
                double output = 0;

                output = sedimentCarried - sedimentCapacity;
                sedimentCarried = sedimentCapacity;

                return output;
            }
        }

		
        private Stack<WaterParticle>[,] water;
		
        private double[,] waterB;
		
        private WaterParticleSystem waterp;
		
        // Depth of a single water particle
        private double waterSize;

		private void settleWater()
        {
            int passes = 10;
            
            for (int p = 0; p < passes; p++)
            {
                int[] xOrder = generateRandomOrder(xSize);
                int[] yOrder = generateRandomOrder(ySize);
                foreach (int x in xOrder)
                {
                    foreach (int y in yOrder)
                    {
                        bool cont = true;

                        while (cont)
                        {
                            int minx = 0;
                            int miny = 0;
                            double minHeight = double.MaxValue;
                            for (int nx = -1; nx <= 1; nx++)
                            {
                                for (int ny = -1; ny <= 1; ny++)
                                {
                                    // make sure we don't go out of bounds
                                    if (x + nx >= 0 && x + nx < xSize && y + ny >= 0 && y + ny < ySize)
                                    {
                                        if (terrain[x + nx, y + ny] + water[x + nx, y + ny].Count * waterSize < minHeight)
                                        {
                                            minHeight = terrain[x + nx, y + ny] + water[x + nx, y + ny].Count * waterSize;
                                            minx = x + nx;
                                            miny = y + ny;
                                        }
                                    }
                                }
                            }
                            if (!(x == minx && y == miny) && water[x, y].Count != 0 && terrain[x, y] + water[x, y].Count * waterSize - minHeight > waterSize)
                            {
                                WaterParticle moved = water[x, y].Pop();
                                water[minx, miny].Push(moved);
                            }
                            else
                            {
                                cont = false;
                            }
                        }
                    }
                }
            }
        }
		
        public void waterSystem(int numParticles)
        {
            Bitmap waterMap;
            Bitmap heightMap;
            var form = new Form1();
            waterp = new WaterParticleSystem(numParticles);
            Random rand = new Random();

            form.Show();

            for (int p = 0; p < numParticles; p++)
            {
                Vector pos = new Vector(rand.NextDouble() * xActualSize, rand.NextDouble() * yActualSize);
                WaterParticleSystem.Particle particle = new WaterParticleSystem.Particle(pos);
                waterp.addParticle(particle);
            }
            for (int p = 0; p < 500; p++)
            {
                
                waterp.runStep(normalMap, xActualSize / xSize, yActualSize / ySize, xSize, ySize);

                waterMap = getWaterParticleMap();
                form.textBox1.Text = p.ToString();
                form.pictureBox1.Image = waterMap;
                heightMap = getHeightBitmap();
                form.pictureBox2.Image = heightMap;
                form.Update();
            }
        }

        public void hydraulicErosion(double solubility, double rainChance, double evapChance, int passes)
        {
            // random generator for rain, evap chances
            Random rand = new Random();
            Bitmap waterMap = getWaterMap();
            Bitmap heightMap = getHeightBitmap();
            var form = new Form1();
            // solubility represents the fraction of the water particle size that can be filled with sediment
            double maxCapacity = solubility * waterSize * 20;

            form.Show();
            form.pictureBox1.Image = waterMap;
            form.pictureBox2.Image = heightMap;
            form.Update();

            for (int p = 0; p < passes; p++)
            {
                for (int x = 0; x < xSize; x++)
                {
                    for (int y = 0; y < ySize; y++)
                    {
                        // decide if we are going to rain on this square on this pass
                        if (rand.NextDouble() < rainChance)
                        {
                            water[x, y].Push(new WaterParticle(0, 0));
                            
                        }
                        
                        //calculate the number of particles to remove via evaporation in this location
                        int waterToRemove = 0;
                        foreach (WaterParticle w in water[x, y])
                        {
                            if (rand.NextDouble() < evapChance)
                            {
                                waterToRemove++;
                            }
                        }

                        //actually remove the particles, drop their sediment load in place
                        for (int i = 0; i < waterToRemove; i++)
                        {
                            WaterParticle removed = water[x, y].Pop();
                            terrain[x, y] += removed.getCarried();
                        }

                        //iterate through the stack, reduce the capacities of each, and drop some sediment. This means water
                        //which hasn't moved for a while will lose capacity
                        foreach (WaterParticle w in water[x,y])
                        {
                            w.setCapacity(w.getCapacity() * .3);
                            double materialMoved = w.calculateLoad();
                            terrain[x, y] += materialMoved;
                            erosion[x, y] += Math.Abs(materialMoved);
                        }

                        //figure out if the top particle should drain to a neighbor
                        bool cont = true;

                        while (cont)
                        {
                            int minx = 0;
                            int miny = 0;
                            double minHeight = double.MaxValue;
                            for (int nx = -1; nx <= 1; nx++)
                            {
                                for (int ny = -1; ny <= 1; ny++)
                                {
                                    // make sure we don't go out of bounds
                                    if (x + nx >= 0 && x + nx < xSize && y + ny >= 0 && y + ny < ySize)
                                    {
                                        if (terrain[x + nx, y + ny] + water[x + nx, y + ny].Count * waterSize < minHeight)
                                        {
                                            minHeight = terrain[x + nx, y + ny] + water[x + nx, y + ny].Count * waterSize;
                                            minx = x + nx;
                                            miny = y + ny;
                                        }
                                    }
                                }
                            }
                            if (!(x == minx && y == miny) && water[x, y].Count != 0 && terrain[x, y] + water[x, y].Count * waterSize - minHeight > waterSize)
                            {
                                // calculate the slope in radians
                                double slope = Math.Atan(terrain[x, y] + water[x, y].Count * waterSize - minHeight);
                                // capacity = slope / (Pi / 2) * maxCapacity
                                double capacity = (slope / (Math.PI / 2)) * maxCapacity;
                                // set the new capacity based on the move the particle is about to make
                                water[x, y].Peek().setCapacity(capacity);
                                // calculateLoad() returns the amount of material the particle is taking or leaving, and sets the new carried amount
                                double materialMoved = water[x, y].Peek().calculateLoad();
                                terrain[x, y] += materialMoved;
                                erosion[x, y] += Math.Abs(materialMoved);
                                // move the particle to its lowest neighbor
                                water[minx, miny].Push(water[x, y].Pop());
                            }
                            else
                            {
                                cont = false;
                            }
                        }
                    }
                }
                waterMap = getWaterMap();
                form.textBox1.Text = p.ToString();
                form.pictureBox1.Image = waterMap;
                heightMap = getHeightBitmap();
                form.pictureBox2.Image = heightMap;
                form.Update();
            }
            //settleWater();
            normalizeTerrain();
            normalizeErosion();
        }

        public void altHydraulicErosion(double solubility, double rainChance, double evapChance, int passes)
        {
            // random generator for rain, evap chances
            Random rand = new Random();
            Bitmap waterMap = getWaterMapB();
            Bitmap heightMap = getHeightBitmap();
            var form = new Form1();

            form.Show();
            form.pictureBox1.Image = waterMap;
            form.pictureBox2.Image = heightMap;
            form.Update();

            for (int p = 0; p < passes; p++)
            {
                for (int x = 0; x < xSize; x++)
                {
                    for (int y = 0; y < ySize; y++)
                    {
                        // add water to this square, based on rain amount
                        waterB[x, y] += waterSize * rainChance;

                        //figure out where the current cell's water should flow
                        bool[,] lowerNeighbors = new bool[3, 3];
                        int lowNeighborCount = 0;
                        double totalLowerNeighborHeight = 0;
                        double totalDifference = 0;
                        double totalNeighborhoodHeight = terrain[x, y] + waterB[x, y];

                        for (int nx = -1; nx <= 1; nx++)
                        {
                            for (int ny = -1; ny <= 1; ny++)
                            {
                                // make sure we don't go out of bounds
                                if (x + nx >= 0 && x + nx < xSize && y + ny >= 0 && y + ny < ySize)
                                {
                                    if (nx == 0 && ny == 0)
                                    {
                                        lowerNeighbors[nx + 1, ny + 1] = false;
                                    }
                                    else if ((terrain[x, y] + waterB[x, y]) - (terrain[x + nx, y + ny] + waterB[x + nx, y + ny]) > 0)
                                    {
                                        lowerNeighbors[nx + 1, ny + 1] = true;
                                        lowNeighborCount++;
                                        totalLowerNeighborHeight += terrain[x + nx, y + ny] + waterB[x + nx, y + ny];
                                        totalDifference += (terrain[x, y] + waterB[x, y]) - (terrain[x + nx, y + ny] + waterB[x + nx, y + ny]);
                                        totalNeighborhoodHeight += terrain[x + nx, y + ny] + waterB[x + nx, y + ny];
                                    }
                                    else
                                    {
                                        lowerNeighbors[nx + 1, ny + 1] = false;
                                    }
                                }
                            }
                        }

                        double avgNeighborAlt = totalLowerNeighborHeight / lowNeighborCount;
                        double avgAltitude = (totalLowerNeighborHeight + (terrain[x, y] + waterB[x, y])) / (lowNeighborCount + 1) ;
                        
                        double totalWaterMoved = 0;

                        if ((terrain[x, y] + waterB[x, y]) - avgNeighborAlt > 0.00001)
                        {
                            sediment[x, y] += waterB[x, y] * solubility * Math.Min(0.1, ((terrain[x, y] + waterB[x, y]) - avgNeighborAlt));
                            terrain[x, y] -= waterB[x, y] * solubility * Math.Min(0.1, ((terrain[x, y] + waterB[x, y]) - avgNeighborAlt));
                        }

                        double currentSediment = sediment[x, y];
                        for (int nx = -1; nx <= 1; nx++)
                        {
                            for (int ny = -1; ny <= 1; ny++)
                            {
                                // make sure we don't go out of bounds
                                if (x + nx >= 0 && x + nx < xSize + 1 && y + ny >= 0 && y + ny < ySize + 1)
                                {
                                    if (lowerNeighbors[nx + 1, ny + 1])
                                    {
                                        double difference = (waterB[x, y] + terrain[x, y]) - (waterB[x + nx, y + ny] + terrain[x + nx, y + ny]);
                                        double waterMoved = Math.Min(waterB[x,y], terrain[x, y] + waterB[x, y] - avgAltitude) * (difference / totalDifference);
                                        waterB[x + nx, y + ny] += waterMoved;
                                        waterB[x, y] -= waterMoved;
                                        sediment[x + nx, y + ny] += waterMoved * currentSediment;
                                        totalWaterMoved += waterMoved;
                                    }
                                }
                            }
                        }
                        
                        sediment[x, y] -= totalWaterMoved * currentSediment;

                        waterB[x, y] *= (1 - evapChance);

                        double maxSediment = waterB[x, y] * solubility * .0001;

                        if (sediment[x,y] > maxSediment)
                        {
                            terrain[x, y] += sediment[x, y] - maxSediment;
                            sediment[x, y] -= sediment[x, y] - maxSediment; 
                        }
                    }
                }
                waterMap = getWaterMapB();
                form.textBox1.Text = p.ToString();
                form.pictureBox1.Image = waterMap;
                heightMap = getHeightBitmap();
                form.pictureBox2.Image = heightMap;
                form.Update();
            }
            //normalizeTerrain();
            //normalizeErosion();
            for (int x = 0; x < xSize; x++)
            {
                for (int y = 0; y < ySize; y++)
                {
                    terrain[x, y] += sediment[x, y];
                }
            }
        }
		        // generate grayscale watermap
        public Bitmap getWaterParticleMap(int threshold)
        {
            Bitmap output = new Bitmap(xSize, ySize);
            int output8;

            /*
            int max = 0;

            for (int x = 0; x < xSize; x++)
            {
                for (int y = 0; y < ySize; y++)
                {
                    max = Math.Max(max, water[x, y].Count);
                }
            }
            */

            for (int x = 0; x < xSize; x++)
            {
                for (int y = 0; y < ySize; y++)
                {
                    if (water[x, y].Count > threshold)
                    {
                        output8 = (int)(water[x, y].Count * waterSize * 255 * 10);
                        if (output8 < 0) output8 = 0;
                        if (output8 > 255) output8 = 255;
                        output.SetPixel(x, y, Color.FromArgb(255, output8, output8, output8));
                    }
                    else
                    {
                        output.SetPixel(x, y, Color.FromArgb(255, 0, 0, 0));
                    }
                }
            }

            return output;
        }

		


        public Bitmap getWaterMapB()
        {
            Bitmap bmp = new Bitmap(xSize, ySize);
            // bmp channel values are 8 bits
            int output8;

            for (int x = 0; x < xSize; x++)
            {
                for (int y = 0; y < ySize; y++)
                {
                    output8 = (int)(waterB[x, y] * 255 * 30);
                    if (output8 < 0) output8 = 0;
                    if (output8 > 255) output8 = 255;
                    bmp.SetPixel(x, y, Color.FromArgb(255, output8, output8, output8));
                }
            }
            return bmp;
        }
		
        public Bitmap getWaterParticleMap()
        {
            Bitmap output = new Bitmap(xSize, ySize);

            /*for (int x = 0; x < xSize; x++)
            {
                for (int y = 0; y < ySize; y++)
                {
                    output.SetPixel(x, y, Color.FromArgb(0, 0, 0, 0));
                }
            }*/

            output = getHeightBitmap();

            for (int i = 0; i < waterp.getNumParticles(); i++)
            {
                Vector position = waterp.getParticleAt(i).getPosition();
                int xPos = (int)(position.X / (xActualSize / xSize));
                int yPos = (int)(position.Y / (yActualSize / ySize));
                if (xPos >= 0 && yPos >= 0 && xPos < xSize && yPos < ySize)
                {
                    output.SetPixel(xPos, yPos, Color.Red);
                }
            }

            return output;
        }

		


        /* UNUSED OLD FUNCTIONS
        public double PerlinNoise(double x, double y, double z)
        {
            if (repeat > 0)
            {
                x %= repeat;
                y %= repeat;
                z %= repeat;
            }
            // calculate the unit cube that the point is located in
            int xi = (int)x & 255;
            int yi = (int)y & 255;
            int zi = (int)z & 255;
            // calulate the local coordinates within the world unit cube
            double xf = x - (int)x;
            double yf = y - (int)y;
            double zf = z - (int)z;

            double u = Fade(xf);
            double v = Fade(yf);
            double w = Fade(zf);

            // hash the coordinates surrounding the input coordinate
            int aaa, aba, aab, abb, baa, bba, bab, bbb;
            aaa = p[p[p[xi] + yi] + zi];
            aba = p[p[p[xi] + Inc(yi)] + zi];
            aab = p[p[p[xi] + yi] + Inc(zi)];
            abb = p[p[p[xi] + Inc(yi)] + Inc(zi)];
            baa = p[p[p[Inc(xi)] + yi] + zi];
            bba = p[p[p[Inc(xi)] + Inc(yi)] + zi];
            bab = p[p[p[Inc(xi)] + yi] + Inc(zi)];
            bbb = p[p[p[Inc(xi)] + Inc(yi)] + Inc(zi)];

            // Gradient function calculates the dot product between the psuedorandom vector and the location vector from the 8 surrounding corners of the unit cube
            // These are then interpolated based on the faded u, v, w values created earlier
            double x1, x2, y1, y2;
            x1 = Lerp(Grad(aaa, xf, yf, zf),
                      Grad(baa, xf - 1, yf, zf), u);
            x2 = Lerp(Grad(aba, xf, yf - 1, zf),
                      Grad(bba, xf - 1, yf - 1, zf), u);
            y1 = Lerp(x1, x2, v);
            x1 = Lerp(Grad(aab, xf, yf, zf - 1),
                      Grad(bab, xf - 1, yf, zf - 1), u);
            x2 = Lerp(Grad(abb, xf, yf - 1, zf - 1),
                      Grad(bbb, xf - 1, yf - 1, zf - 1), u);
            y2 = Lerp(x1, x2, v);

            return (Lerp(y1, y2, w) + 1) / 2; // return interpolated result, change range from -1...1 to 0...1
        }

        public double ExpPerlinNoise(double x, double y, double z)
        {
            // if the magnitude isn't initialized, do so using mu = 1
            if (m[0] != 1.0)
            {
                InitExpMagTable(1);
            }
            if (repeat > 0)
            {
                x %= repeat;
                y %= repeat;
                z %= repeat;
            }
            // calculate the unit cube that the point is located in
            int xi = (int)x & 255;
            int yi = (int)y & 255;
            int zi = (int)z & 255;
            // calulate the local coordinates within the world unit cube
            double xf = x - (int)x;
            double yf = y - (int)y;
            double zf = z - (int)z;

            double u = Fade(xf);
            double v = Fade(yf);
            double w = Fade(zf);

            // hash the coordinates surrounding the input coordinate
            int aaa, aba, aab, abb, baa, bba, bab, bbb;
            aaa = p[p[p[xi] + yi] + zi];
            aba = p[p[p[xi] + Inc(yi)] + zi];
            aab = p[p[p[xi] + yi] + Inc(zi)];
            abb = p[p[p[xi] + Inc(yi)] + Inc(zi)];
            baa = p[p[p[Inc(xi)] + yi] + zi];
            bba = p[p[p[Inc(xi)] + Inc(yi)] + zi];
            bab = p[p[p[Inc(xi)] + yi] + Inc(zi)];
            bbb = p[p[p[Inc(xi)] + Inc(yi)] + Inc(zi)];

            // Gradient function calculates the dot product between the psuedorandom vector and the location vector from the 8 surrounding corners of the unit cube
            // These are then interpolated based on the faded u, v, w values created earlier
            // For the exponential magnitude version, multiply the unit cube corners by a magnitude value hashed from the coordinates
            double x1, x2, y1, y2;
            x1 = Lerp(Grad(aaa, xf * m[aaa], yf * m[aaa], zf * m[aaa]),
                      Grad(baa, (xf - 1) * m[baa], yf * m[baa], zf * m[baa]), u);
            x2 = Lerp(Grad(aba, xf * m[aba], (yf - 1) * m[aba], zf * m[aba]),
                      Grad(bba, (xf - 1) * m[bba], (yf - 1) * m[bba], zf * m[bba]), u);
            y1 = Lerp(x1, x2, v);
            x1 = Lerp(Grad(aab, xf * m[aab], yf * m[aab], (zf - 1) * m[aab]),
                      Grad(bab, (xf - 1) * m[bab], yf * m[bab], (zf - 1) * m[bab]), u);
            x2 = Lerp(Grad(abb, xf * m[abb], (yf - 1) * m[abb], (zf - 1) * m[abb]),
                      Grad(bbb, (xf - 1) * m[bbb], (yf - 1) * m[bbb], (zf - 1) * m[bbb]), u);
            y2 = Lerp(x1, x2, v);

            return (Lerp(y1, y2, w) + 1) / 2; // return interpolated result, change range from -1...1 to 0...1
        }

        public double OctavePerlin(double x, double y, double z, double frequency, int octaves, double persistance, double lacunarity)
        {
            double total = 0;
            double amplitude = 1;
            double maxValue = 0;
            for (int i = 0; i < octaves; i++)
            {
                total += PerlinNoise(x * frequency, y * frequency, z * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= persistance;
                frequency *= lacunarity;
            }
            return total / maxValue;
        }

        public double OctaveExpPerlin(double x, double y, double z, double frequency, int octaves, double persistance, double lacunarity)
        {
            double total = 0;
            double amplitude = 1;
            double maxValue = 0;
            for (int i = 0; i < octaves; i++)
            {
                total += ExpPerlinNoise(x * frequency, y * frequency, z * frequency) * amplitude;
                maxValue += amplitude;
                amplitude *= persistance;
                frequency *= lacunarity;
            }
            return total / maxValue;
        }
        */

		using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Media.Media3D;

namespace TerrainGenerator
{
    class WaterParticleSystem
    {
        public struct Particle
        {
            Vector position;
            Vector velocity;
            int life;

            public Particle(Vector pos)
            {
                position = pos;
                velocity = new Vector();
                life = 0;
            }

            public Vector getPosition()
            {
                return position;
            }

            public Vector getVelocity()
            {
                return velocity;
            }

            public void setPosition(Vector p)
            {
                position = p;
            }

            public void setVelocity(Vector v)
            {
                velocity = v;
            }

            public void stepLife()
            {
                life++;
            }

            public int getLife()
            {
                return life;
            }
        }

        public WaterParticleSystem(int size)
        {
            this.size = size;
            particles = new Particle[size];
        }

        int size = 0;
        int elements = 0;
        Particle[] particles;
        float flowSpeed = 50;
        double flowMomentum = 0.5;
        double minSpeed = 0.75;
        int minLife = 20;
        Random rand = new Random();

        public int getSize()
        {
            return size;
        }

        public int getNumParticles()
        {
            return elements;
        }

        public void setSize(int size)
        {
            this.size = size;
            particles = new Particle[size];
        }

        public Particle getParticleAt(int index)
        {
            return particles.ElementAt(index);
        }

        public void addParticle(Particle w)
        {
            if (elements < size)
            {
                particles[elements] = w;
                elements++;
            }
        }

        public void runStep(Vector3D[,] normals, double xScale, double yScale, int xSize, int ySize)
        {
            for (int i = 0; i < particles.Length; i++)
            {
                int xPos = (int)(particles[i].getPosition().X / xScale);
                int yPos = (int)(particles[i].getPosition().Y / yScale);
                if (xPos >= 0 && xPos < xSize && yPos >= 0 && yPos < ySize)
                {
                    Vector v = new Vector(normals[xPos, yPos].X, -normals[xPos, yPos].Y);
                    v *= flowSpeed;
                    v = (v * 1 / flowMomentum) + (particles[i].getVelocity() * flowMomentum);
                    particles[i].setVelocity(v);
                    particles[i].setPosition(particles[i].getPosition() + particles[i].getVelocity());
                    particles[i].stepLife();
                    if (particles[i].getVelocity().Length < minSpeed && particles[i].getLife() > minLife)
                    {
                        particles[i] = new Particle(new Vector(rand.Next(xSize) * xScale, rand.Next(ySize) * yScale));
                    }
                }
            }
        }
    }
}

            /*
            int xSize = 512;
            int ySize = xSize;
            float xMapSize = 20000;
            float yMapSize = xMapSize;
            float maxAlt = 5000;
            int octaves = 8;
            double frequency = 1;
            double persistance = .45;
            double lacunarity = 1.95;
            double mu = 1.01; // useful range - 1.0 - about 1.02
            double xOffset = 9.6;
            double yOffset = 23.7;
            
            string filename = "terrain.raw";
            string bmpFile = "terrain.bmp";
            string texFile = "texture.bmp";
            string tifFile = "terrain.tif";
            string inBmpFile = "squarebasin.bmp";
            string erosionMap = "erosionmap.bmp";
            string depositionMap = "depositionMap.bmp";
            string waterMap = "watermap.bmp";
            string waterRaw = "water.raw";
            string normalMap = "normalmap.bmp";
            string slopeMap = "slope.bmp";
            string inTif = "input.tif";
            Bitmap inBmp = new Bitmap(inBmpFile);
            Bitmap bmp = new Bitmap(xSize, ySize);
            Terrain terrain = new Terrain(xSize, ySize, xMapSize, yMapSize, maxAlt);
            ColorBlend cb = new ColorBlend();
            cb.Positions = new[] { 0, 1 / 3f, 1 / 2f, 3 / 4f, 7 / 8f, 1 };
            cb.Colors = new[] { Color.FromArgb(61, 84, 51), Color.FromArgb(35, 50, 32), Color.FromArgb(35, 50, 32), Color.FromArgb(160, 153, 147), Color.FromArgb(247, 247, 251), Color.FromArgb(247, 247, 251) };

            //terrain.terrainFromBmp(inBmp);
            //terrain.terrainFromTIFF(inTif);
            //terrain.addTerrainNoise(0, xOffset, yOffset, frequency, octaves, persistance, lacunarity, mu);
            terrain.generateTerrain(xOffset, yOffset, frequency, octaves, persistance, lacunarity, mu);
            terrain.setTextureSample(cb);
            bmp = terrain.getHeightBitmap();
            terrain.saveHeightRaw("beforeErosion.raw");
            bmp.Save("terrainBeforeErosion.bmp");
            terrain.thermalErosion(45, 25);
            terrain.vFieldHydroErosion(.01, .1, .05, .05, .1, .00005, 1, 800);
            terrain.saveHeightRaw(filename);
            terrain.saveTIFF(tifFile);
            bmp = terrain.getNormalMap();
            bmp.Save(normalMap);
            bmp = terrain.getHeightBitmap();
            bmp.Save(bmpFile);
            bmp = terrain.getTexture();
            bmp.Save(texFile);
            bmp = terrain.getErosionMap();
            bmp.Save(erosionMap);
            bmp = terrain.getDepositionMap();
            bmp.Save(depositionMap);
            bmp = terrain.getThermalErosionMap();
            bmp.Save("thermalErosion.bmp");
            bmp = terrain.getTalusMap();
            bmp.Save("talus.bmp");
            bmp = terrain.getWaterMap(.5f);
            bmp.Save(waterMap);
            terrain.saveWaterRaw(waterRaw,5);
            bmp = terrain.getSlopeMap();
            bmp.Save(slopeMap);
            bmp = terrain.getSplatMap(1000, 5000, 500, 0, 0, 40, 0, 15, .1);
            bmp.Save("snow.bmp");
            bmp = terrain.getSplatMap(0, 1500, 0, 1000, 0, 45, 0, 20, .3);
            bmp.Save("trees.bmp");
            bmp = terrain.getSplatMap(0, 1500, 0, 1000, 0, 65, 0, 20, .4);
            bmp.Save("grass.bmp");*/
			
        /*
        // pick a random vector based on the hash
        private static double Grad(int hash, double x, double y, double z)
        {
            switch (hash & 0x0F)
            {
                case 0x0: return x + y;
                case 0x1: return -x + y;
                case 0x2: return x - y;
                case 0x3: return -x - y;
                case 0x4: return x + z;
                case 0x5: return -x + z;
                case 0x6: return x - z;
                case 0x7: return -x - z;
                case 0x8: return y + z;
                case 0x9: return -y + z;
                case 0xA: return y - z;
                case 0xB: return -y - z;
                case 0xC: return y + x;
                case 0xD: return -y + z;
                case 0xE: return y - x;
                case 0xF: return -y - z;
                default: return 0; // should never happen
            }
        }
        */